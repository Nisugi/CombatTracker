=begin
  CombatTracker.lic
    Database based combat event tracking. This is the "recorder", it creates a relational database 
    that tags creatures to hunting sessions, attacks to creatures, and flares to attacks.
    
    The end goal is a data tracking system that can be used to create various reports such as:
    What happened to creature #8282851?
    How many creatures did I murder last hunt?
    What's the average damage of my briar flares? Crit distribution?
      and many more...


        author: Nisugi
  contributors: Nisugi
          game: Gemstone
          tags: hunting, combat, tracking
       version: 0.1

  Change Log:
  v0.1
    - Alpha release
=end

require 'sequel'

unless Script.exists?("combattracker_parser.rb")
  puts("CombatTracker requires the script combattracker_parser.rb.")
  puts("Please download it and try again.")
  puts(";repository download combattracker_parser")
  exit
end
unless defined?(CombatTracker::Parser)
  Script.run("combattracker_parser")
end

module CombatTracker
  # ------------------------------------------------------------
  # Configuration
  # ------------------------------------------------------------
  module Config
    class << self
      attr_accessor :session_timeout, :flush_interval, :max_cache_rows, :db_path
    end

    self.session_timeout = 180      # seconds of inactivity before a new session
    self.flush_interval  = 300      # seconds between background DB flushes
    self.max_cache_rows  = 10_000   # early‑flush threshold
    self.db_path         = File.join(DATA_DIR, XMLData.game, Char.name, 'combat.db')
  end

  # ------------------------------------------------------------
  # Debug messaging
  # ------------------------------------------------------------
  module Log
    LEVELS = %i[VERBOSE DEBUG INFO WARN ERROR].freeze
    @level = :DEBUG

    class << self
      # ensure we're always reading the same @level
      def level
        @level
      end

      # normalize input to lowercase symbol and store it
      def level=(lvl)
        if LEVELS.include?(lvl)
          @level = lvl
        else
          warn "[CB WARN ] Unknown log level #{lvl.inspect}; keeping #{@level}"
        end
      end

      def log(level, ctx, msg)
        return if LEVELS.index(level) < LEVELS.index(@level)
        timestamp = Time.now.strftime('%H:%M:%S')
        respond "[#{timestamp}] [CB #{level.to_s.upcase.ljust(5)}] [#{ctx}] #{msg}"
      end
    end
  end

  # ------------------------------------------------------------
  # Database connection & schema bootstrap
  # ------------------------------------------------------------
  module DB
    extend self

    def conn
      @conn ||= Sequel.sqlite(
        Config.db_path,
        timeout:      10_000,
        journal_mode: :wal,
        synchronous:  :normal
      )
    end

    def load_schema!
      path = File.expand_path('db_schema.sql', DATA_DIR)
      return unless conn.tables.empty?
      conn.run(File.read(path))
      Log.log(:info, :DB, "Schema initialized -> #{path}")
      conn.run 'PRAGMA foreign_keys = ON'
    end
  end
  DB.load_schema!

  # ------------------------------------------------------------
  # Seed lookup tables from parser definitions
  # ------------------------------------------------------------
  module DBSeeder
    def self.seed!
      conn = DB.conn

      Parser::ATTACK_DEFS.each_with_index do |atk_def|
        conn[:attack_types]
          .insert_conflict(target: :name, do_nothing: true)
          .insert(name: atk_def.name.to_s.upcase)
      end

      Parser::FLARE_DEFS.each_with_index do |fl_def|
        conn[:flare_types]
          .insert_conflict(target: :name, do_nothing: true)
          .insert(name: fl_def.name.to_s.upcase)
      end

      Parser::OUTCOME_DEFS.each_with_index do |out_def|
        conn[:outcome_types]
          .insert_conflict(target: :name, do_nothing: true)
          .insert(name: out_def.type.to_s.upcase)
      end

      Parser::RESOLUTION_DEFS.each_with_index do |res_def|
        conn[:resolution_types]
          .insert_conflict(target: :name, do_nothing: true)
          .insert(name: res_def.type.to_s.upcase)
      end

      # 2) Status types
      Parser::STATUS_DEFS.each_with_index do |st_def|
        conn[:status_types]
          .insert_conflict(target: :name, do_nothing: true)
          .insert(name: st_def.type.to_s.upcase)
      end



      Log.log(:info, "DBSEED", "Seeded lookup tables from Parser defs")
    end
  end
  DBSeeder.seed!

  # ------------------------------------------------------------
  # Debug messaging for inserting to DB
  # ------------------------------------------------------------
  module DebugInsert
    def self.insert(table, row)
      Log.log(:DEBUG, "DB-INS", "-> #{table}: #{row.inspect}") unless table == :resolution_components
      DB.conn[table].insert(row)
    rescue SQLite3::ConstraintException => e
      Log.log(:ERROR, "DB-INS", "FAILED #{table}: #{e.class}: #{e.message}")
      # show what FK’s this table has
      fk_defs = DB.conn["PRAGMA foreign_key_list(#{table})"].all
      Log.log(:ERROR, "DB-INS", "FK definitions for #{table}: #{fk_defs.inspect}")
      # show any dangling child rows
      violations = DB.conn['PRAGMA foreign_key_check'].all
      Log.log(:ERROR, "DB-INS", "Current FK violations: #{violations.inspect}")
      raise
    end
  end

  # ------------------------------------------------------------
  # Simple Foreign Key helpers
  # ------------------------------------------------------------
  module Lookup
    def self.id(table, name)
      DB.conn[table].first(name: name.to_s.upcase)&.fetch(:id) || raise("Unknown #{table}: #{name}")
    end
  end

  # ------------------------------------------------------------
  # Session manager – ensures we always have an active session
  # ------------------------------------------------------------
  module Session
    extend self

    @id = nil
    @seq = 0
    @last_seen = nil

    def current_id = ensure_session!
    def next_sequence = ensure_session! && (@seq += 1)

    private

    def ensure_session!
      now  = Time.now
      char = defined?(Char) ? Char.name : 'Unknown'

      if @id && !DB.conn[:combat_sessions].where(id: @id).count.positive?
        Log.log(:INFO, "SESSION", "Session #{@id} not found in database, resetting state")
        @id = nil
        @seq = 0
      end

      if @id.nil? || now - (@last_seen || 0) > Config.session_timeout
        DB.conn[:combat_sessions].where(id: @id).update(ended_at: now) if @id
        @id  = DB.conn[:combat_sessions].insert(character_name: char, started_at: now, last_event_at: now)
        raise "Failed to create session" unless DB.conn[:combat_sessions].where(id: @id).count > 0
        @seq = 0
      else
        DB.conn[:combat_sessions].where(id: @id).update(last_event_at: now)
      end

      @last_seen = now
      @id
    end
  end

  # ------------------------------------------------------------
  # Lightweight row cache + bulk flusher
  # ------------------------------------------------------------
  module Store
    CACHE = Hash.new { |h, k| h[k] = [] }
    MUTEX = Mutex.new

    module_function

    def push(table, row)
      MUTEX.synchronize { CACHE[table] << row }
      Flusher.flush! if CACHE[table].size >= Config.max_cache_rows
    end
  end

  module Flusher
    TABLES = %i[
      creature_instances attack_events attack_resolutions resolution_components
      status_events flare_events damage_components
    ].freeze

    module_function

    def flush!
      batches = nil
      Store::MUTEX.synchronize { batches = Store::CACHE.transform_values(&:dup) }
      return if batches.values.all?(&:empty?)

      DB.conn.transaction do
        TABLES.each do |t|
          rows = batches[t] or next
          rows = dedup_creatures(rows) if t == :creature_instances
          DB.conn[t].multi_insert(rows, slice: 1_000) unless rows.empty?
        end
      end

      Store::MUTEX.synchronize { TABLES.each { |tbl| Store::CACHE[tbl].clear } }
    rescue => e
      Log.log(:error, :FLUSH, "flush failed → #{e.message}")
    end

    def dedup_creatures(rows)
      rows
        .group_by { |r| [r[:session_id], r[:exist_id]] }
        .values
        .map { |grp| grp.max_by { |r| r[:last_seen_at] } }
    end

    def start_background!
      Thread.new do
        loop do
          sleep Config.flush_interval
          flush!
        end
      end
    end
  end
  Flusher.start_background!

  # ------------------------------------------------------------
  # Processor – turns a buffered chunk into persisted records
  # ------------------------------------------------------------
  module Processor
    module_function

    def process(chunk)
      events = parse_events(chunk)
      return if events.empty?

      DB.conn.transaction { events.each { |ev| persist(ev) } }
    end

    # -- parse ---------------------------------------------------
    def parse_events(lines)
      events = []
      current = nil

      lines.each do |ln|
        if (a = Parser.parse_attack(ln))
          events << current if current
          current = init_event(a)

        elsif current && ln =~ /\.\.\. and hit for (?<d>\d+) points? of damage!/i
          current[:damage] += Regexp.last_match[:d].to_i
          current[:ctx]     = :attack

        elsif current && ln =~ /\.\.\. (?<d>\d+) points of damage!/i
          dmg = Regexp.last_match[:d].to_i
          (current[:ctx] == :flare ? current[:flares].last : current)[:damage] += dmg

        elsif current && (r = Parser.parse_resolution(ln))
          current[:resolution] = r

        elsif current && (l = Parser.parse_lodged(ln))
          current[:lodged] = l
          if current[:target][:id].nil?
            t = Parser.extract_link(ln) || { id: nil, noun: nil, name: raw_t }
            current[:target] = t[:target] || {}
          end

        elsif current && (o = Parser.parse_outcome(ln))
          current[:outcome] = o

        elsif current && (s = Parser.parse_status(ln))
          current[:statuses] << s

        elsif current && (f = Parser.parse_flare(ln))
          current[:flares]    << f.merge(damage: 0, crit: nil)
          current[:ctx] = :flare



        elsif current && (c = CritRanks.parse(ln.gsub(/<.+?>/,'')).values.first)
          target = current[:ctx] == :flare ? current[:flares].last : current
          target[:crit] = { type: c[:type], location: c[:location], rank: c[:rank], raw: ln.strip }

        end
      end
      events << current if current
      events
    end

    def init_event(attack_info)
      {
        name: attack_info[:name],
        target: attack_info[:target] || {},
        resolution: nil,
        damage: 0,
        crit: { type: nil, location: nil, rank: nil, raw: nil },
        statuses: [],
        flares: [],
        ctx: :attack
      }
    end

    # -- persist -------------------------------------------------
    def persist(ev)
      session_id = Session.current_id
      seq        = Session.next_sequence
      tgt        = ev[:target]
      ci_id      = upsert_creature(session_id, tgt) if tgt[:id]
      now        = Time.now
      
      begin
        outcome_id = Lookup.id(:outcome_types, ev[:outcome])
      rescue
        Log.log(:VERBOSE, "OUTCOME", "Unknown outcome: #{ev[:outcome]}, defaulting to HIT")
        outcome_id = 1
      end

      attack_id = CombatTracker::DebugInsert.insert(:attack_events, {
        session_id:           session_id,
        sequence:             seq,
        creature_instance_id: ci_id,
        attack_type_id:       Lookup.id(:attack_types, ev[:name]),
        is_fatal:             ev.dig(:crit, :fatal),
        outcome_id:           outcome_id,
        occurred_at:          now,
      })

      damage_component = {
        attack_id: attack_id,
        damage:    ev[:damage],
      }

      if ev[:crit] && ev[:crit][:type] && outcome_id == 1
        damage_component[:location_id] = Lookup.id(:locations, ev.dig(:crit, :location))
        damage_component[:critical_type] = Lookup.id(:critical_types, ev.dig(:crit, :type))
        damage_component[:critical_rank] = ev.dig(:crit, :rank)
      else
        Log.log(:WARN, "CRIT", "No crit message detected for attack #{attack_id}.") if outcome_id == 1
      end
      CombatTracker::DebugInsert.insert(:damage_components, damage_component)

      persist_statuses(ev[:statuses], attack_id, session_id)
      persist_resolution(ev[:resolution], attack_id, seq, session_id) if ev[:resolution]
      persist_flares(ev[:flares], attack_id, seq, tgt, session_id)    if ev[:flares].any?
      persist_lodged(ev[:lodged], attack_id, ci_id, now) if ev[:lodged]
      
    end

    def upsert_creature(session_id, tgt)
      now = Time.now
      Log.log(:DEBUG, "CREATURE", "upsert_creature session_id=#{session_id.inspect}, exist_id=#{tgt[:id]}")
      exists = DB.conn[:combat_sessions].where(id: session_id).count.positive?
      Log.log(:DEBUG, "CREATURE", "  combat_sessions[#{session_id}] exists? #{exists}")
      DB.conn[:creature_instances]
        .insert_conflict(target: %i[session_id exist_id], update: { last_seen_at: now })
        .insert(session_id: session_id, exist_id: tgt[:id], noun: tgt[:noun],
                display_name: tgt[:name], first_seen_at: now, last_seen_at: now)
      DB.conn[:creature_instances].where(session_id:, exist_id: tgt[:id]).get(:id)
    end

    def persist_statuses(sts, atk_id, session_id)
      now = Time.now
      sts.each do |st|
        CombatTracker::DebugInsert.insert(:status_events, {
          applied_by_attack: atk_id,
          status_type:       Lookup.id(:status_types, st),
          started_at:        now,
          ended_at:          nil
        })
      end
    end

    def persist_resolution(res, atk_id, seq, session_id)
      session_id = Session.current_id
      type_id    = Lookup.id(:resolution_types, res[:type])

      # build the full row with all NOT NULL fields
      row = {
        session_id:      session_id,
        attack_id:       atk_id,
        sequence:        seq,
        resolution_type: type_id,
        result_total:    res[:data][:total].to_i,
        d100_roll:       res[:data][:roll].to_i,
        raw_line:        res[:raw]
      }

      # insert and grab its PK
      res_id = CombatTracker::DebugInsert.insert(:attack_resolutions, row)

      # now persist the components as before
      res[:data].each do |k, v|
        next if %i[total roll].include?(k)
        CombatTracker::DebugInsert.insert(:resolution_components, {
          session_id:      session_id,
          sequence:        seq,
          resolution_id:   res_id,
          component_name:  k.to_s.upcase,
          component_value: v.to_i
        })
      end
    end

    def persist_flares(flares, atk_id, seq, tgt, session_id)
      flares.each_with_index do |fl, i|
        flare_event_id = CombatTracker::DebugInsert.insert(:flare_events, {
            session_id:      session_id,
            attack_id:       atk_id,
            attack_sequence: seq,
            flare_sequence:  i + 1,
            flare_type_id:   Lookup.id(:flare_types, fl[:name]),
            is_fatal:        fl.dig(:crit, :fatal)
          })
        
        if fl[:damaging]
          damage_component = {
            flare_id:        flare_event_id,
            damage:          fl[:damage],
          }
          if fl[:crit] && fl[:crit][:type]
            damage_component[:location_id] = Lookup.id(:locations, fl.dig(:crit, :location))
            damage_component[:critical_type] = Lookup.id(:critical_types, fl.dig(:crit, :type))
            damage_component[:critical_rank] = fl.dig(:crit, :rank)
          else
            Log.log(:WARN, "CRIT", "No crit message detected for flare #{flare_event_id}.")
          end
          CombatTracker::DebugInsert.insert(:damage_components, damage_component)
        end
      end
    end

    def persist_lodged(lodged, atk_id, ci_id, time)
      Log.log(:DEBUG, "LODG", "Lodged is #{lodged}.")
      CombatTracker::DebugInsert.insert(:lodged_events, {
        attack_id:    atk_id,
        creature_id:  ci_id,
        location_id:  Lookup.id(:locations, lodged),
        lodged_at:    time,
        removed_at:   nil
      })
    end
  end

  # ------------------------------------------------------------
  # Downstream buffer hook – segments by prompt & queues chunks
  # ------------------------------------------------------------
  DOWNSTREAM_HOOK_ID = 'CombatTracker::downstream'
  PROCESS_QUEUE = Queue.new
  @buffer = []

  class << self
    attr_reader :buffer
  end

  segment_buffer = proc do |server_string|
    CombatTracker.buffer << server_string
    if server_string =~ /<prompt time="\d+">/
      PROCESS_QUEUE << CombatTracker.buffer.shift(CombatTracker.buffer.size)
    end
    server_string
  end
  DownstreamHook.add(DOWNSTREAM_HOOK_ID, segment_buffer)

  before_dying do
    Flusher.flush!
    DownstreamHook.remove(DOWNSTREAM_HOOK_ID)
    DB.conn.disconnect
  end

  loop { Processor.process(PROCESS_QUEUE.pop) }
end
