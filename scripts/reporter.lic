module CombatTracker
  # This module provides functionality for tracking and reporting combat sessions.
  class Reporter
    @type_sequences = {}

    # Retrieves a list of the last n combat sessions, displaying them in a formatted table.
    #
    # @param n [Integer] the number of sessions to retrieve (default is 5)
    # @return [void]
    # @raise [StandardError] if there are no combat sessions recorded
    # @example
    #   CombatTracker::Reporter.session_list(3)
    def self.session_list(n = 5)
      limit = [n.to_i, 1].max

      # Pull the last n sessions, newest first
      sessions = DB.conn[:combat_sessions]
                   .order(Sequel.desc(:id))
                   .limit(limit)
                   .all

      if sessions.empty?
        respond "No combat sessions recorded."
        return
      end

      # Build display rows
      rows = sessions.map do |s|
        [
          Lich::Messaging.make_cmd_link(s[:id].to_s, ";eq CombatTracker::Reporter.session_report(#{s[:id]})"),
          s[:character_name],
          s[:started_at].strftime("%Y-%m-%d %H:%M:%S"),
          s[:last_event_at].strftime("%Y-%m-%d %H:%M:%S"),
          s[:ended_at] ? s[:ended_at].strftime("%Y-%m-%d %H:%M:%S") : ''
        ]
      end

      # Header + column names
      header = "Last #{limit} Combat Sessions"
      cols   = %w[ID Character Started\ At Last\ Event Ended\ At]

      print_ascii_table(header, cols, rows)
    end

    # Generates a detailed report for a specific combat session.
    #
    # @param session_id [Integer, nil] the ID of the session to report on (default is nil, which fetches the most recent session)
    # @return [void]
    # @raise [StandardError] if the specified session does not exist
    # @example
    #   CombatTracker::Reporter.session_report(123)
    def self.session_report(session_id = nil)
      # 1) Determine the session
      sid = if session_id
              session_id.to_i
            else
              DB.conn[:combat_sessions]
                .order(Sequel.desc(:id))
                .get(:id)
            end

      # 2) Validate session exists
      unless DB.conn[:combat_sessions].where(id: sid).any?
        respond "No session ##{sid} found. Showing recent sessions instead:\n\n"
        list_sessions(5)
        return
      end

      session = DB.conn[:combat_sessions].where(id: sid).first

      # 3) Fetch all creature instances for that session
      creatures = DB.conn[:creature_instances]
                    .where(session_id: sid)
                    .order(:first_seen_at)
                    .all

      if creatures.empty?
        respond "No creatures recorded in session ##{sid}."
        return
      end

      # 4) Build header
      header = "Report for Session ##{sid} - #{session[:character_name]}"
      columns = %w[# ID Noun Name First\ Seen Last\ Seen Killed\ At]

      # 5) Build rows: [indent, ordinal, id, noun, display_name, first_seen, last_seen, killed_at]
      rows = creatures.map.with_index(1) do |ci, idx|
        [
          sid.to_s,
          idx.to_s,
          Lich::Messaging.make_cmd_link("##{ci[:exist_id].to_s}", ";eq CombatTracker::Reporter.creature_report(#{ci[:exist_id].to_s})"),
          ci[:noun],
          ci[:display_name],
          ci[:first_seen_at].strftime("%Y-%m-%d %H:%M:%S"),
          ci[:last_seen_at]&.strftime("%Y-%m-%d %H:%M:%S") || '',
          ci[:killed_at]&.strftime("%Y-%m-%d %H:%M:%S") || ''
        ]
      end

      # 6) Print the table
      print_ascii_table(header, columns, rows)
    end

    # Generates a report for a specific creature instance based on either its exist_id or noun.
    #
    # @param creature_arg [Integer, String, nil] the exist_id of the creature or the noun (default is nil)
    # @param idx [Integer, nil] the index of the creature instance if using noun mode (default is nil)
    # @return [void]
    # @raise [StandardError] if the creature does not exist or if the noun is unknown
    # @example
    #   CombatTracker::Reporter.creature_report(12345678)
    def self.creature_report(creature_arg = nil, idx = nil)
      # 1) No args ? usage
      unless creature_arg
        respond <<~USAGE

          Usage:
            creature_report(exist_id)
            creature_report("noun", [index])

          Examples:
            creature_report(12345678)
            creature_report("skald", 2)
            creature_report("berserker", -1)

        USAGE

        list_nouns
        return
      end

      # 2) exist_id mode (only one arg, integer-ish)
      if idx.nil? && creature_arg.to_s =~ /\A\d+\z/
        exist_id = creature_arg.to_i
        ci = DB.conn[:creature_instances]
               .where(exist_id: exist_id)
               .order(Sequel.desc(:first_seen_at))
               .first

        unless ci
          respond "No creature with exist_id #{exist_id} found."
          return
        end

        # we?ve got our creature_instance row
        noun  = ci[:noun]
        ci_id = ci[:id]
        disp  = ci[:display_name]
        header = "Report for #{disp} ##{exist_id}  -  #{noun.upcase} (#{ci_id})"

      else
        # 3) noun + optional index mode
        noun = creature_arg.to_s
        # build noun list & validate
        all = DB.conn[:creature_instances].select_map(:noun).uniq
        unless all.map(&:upcase).include?(noun.upcase)
          respond "Unknown noun ?#{noun}?. Available nouns:"
          list_nouns
          return
        end
        noun = all.find { |n| n.upcase == noun.upcase }

        # build the sequence of instance IDs for this noun
        seq = DB.conn[:creature_instances]
                .where(noun: noun)
                .order(:first_seen_at)
                .select_map(:id)
        if seq.empty?
          respond "No instances of ?#{noun}? found."
          return
        end

        # compute zero-based idx
        index = idx ? idx.to_i : -1
        zero = index > 0 ? index - 1 : seq.size + index
        unless zero.between?(0, seq.size - 1)
          respond "Invalid index #{index} for #{noun} (#{seq.size} instances):"
          list_instance_ordinals(noun, seq); return
        end

        ci_id = seq[zero]
        ci    = DB.conn[:creature_instances].where(id: ci_id).first
        header = "Report for #{noun.upcase} (#{zero+1}/#{seq.size}) ID:#{ci_id} ?#{ci[:display_name]}?"
      end

      # 4) Gather every top-level attack on that creature_instance
      child_ids = DB.conn[:flare_events]
                    .where(Sequel.~(child_attack_id: nil))
                    .select_map(:child_attack_id)

      attack_ids = DB.conn[:attack_events]
               .where(creature_instance_id: ci_id)
               .exclude(id: child_ids)
               .order(:sequence)
               .select_map(:id)

      rows = []
      attack_ids.each_with_index do |aid, idx|
        rows.concat format_attack_tree(aid)
        rows << ['','','','',''] if idx < attack_ids.size - 1
      end

      if rows.empty?
        respond "#{header}\n\n  (no attacks recorded)\n"
      else
        print_ascii_table(header,
                          %w[Attack DMG STATUS CRIT_STUFFS FATAL?],
                          rows)
      end
    end

    # Lists the ordinals of instances for a given noun.
    #
    # @param noun [String] the noun for which to list instances
    # @param seq [Array<Integer>] the sequence of instance IDs
    # @return [void]
    # @example
    #   CombatTracker::Reporter.list_instance_ordinals("skald", [1, 2, 3])
    def self.list_instance_ordinals(noun, seq)
      msg = "\n> #{noun} Instances:"
      seq.each_with_index do |id, i|
        disp = DB.conn[:creature_instances]
                 .where(id: id)
                 .get(:display_name)
        msg += "   #{i+1} => ID #{id} #{disp}"
      end
      respond Lich::Messaging.mono(msg)
    end

        # Generates a report for a specific sequence type and index.
    #
    # @param seq_type [String, nil] The type of sequence to report on. If nil, usage information is displayed.
    # @param idx [Integer, nil] The index of the sequence to report on. If nil, the last sequence is reported.
    # @return [void] Outputs the report to the console.
    # @raise [StandardError] If an unknown sequence type is provided.
    # @example
    #   sequence_report("FLURRY", 2)
    def self.sequence_report(seq_type = nil, idx = nil)
      types = DB.conn[:sequence_types]
                  .select_map(:name)
                  .uniq
                  .sort_by(&:downcase)
      if seq_type.nil?
        puts <<~USAGE

          Usage:
            sequence_report("SEQUENCE_TYPE", [index])

          Examples:
            sequence_report("FLURRY")
            sequence_report("FLURRY", 2)
            sequence_report("FLURRY", -1)

        USAGE
        list_sequence_types
        return
      end

      st = types.find { |n| n.casecmp?(seq_type.to_s) }
      unless st
        puts "Unknown sequence type #{seq_type}. Available:"
        list_sequence_types
        return
      end

      seq_ids = DB.conn[:sequence_events]
                   .join(:sequence_types, id: :sequence_type_id)
                   .where(Sequel[:sequence_types][:name] => st)
                   .order(Sequel[:sequence_events][:id])
                   .select_map(Sequel[:sequence_events][:id])

      if seq_ids.empty?
        puts "No sequences of type #{st} recorded."
        return
      end

      pos = if idx
        i = idx.to_i
        i > 0 ? (i-1) : (seq_ids.size + i)
      else
        seq_ids.size - 1
      end

      unless pos.between?(0, seq_ids.size - 1)
        puts "Invalid index #{idx} for #{st} (#{seq_ids.size} sequences):"
        seq_ids.each_with_index { |id,i| puts "   #{i+1} => Sequence ID #{id}" }
        return
      end

      chosen_id = seq_ids[pos]
      header    = "Sequence #{st.upcase} (#{pos+1}/#{seq_ids.size}) - ID #{chosen_id}"

      child_ids = DB.conn[:flare_events]
                    .where(Sequel.~(child_attack_id: nil))
                    .select_map(:child_attack_id)

      atk_ids = DB.conn[:attack_events]
                      .where(sequence_event_id: chosen_id)
                      .exclude(id: child_ids)
                      .order(:sequence_step)
                      .select_map(:id)

      if atk_ids.empty?
        puts "#{header}\n\n  (no attacks recorded in this sequence)\n"
        return
      end

      rows = []
      atk_ids.each_with_index do |aid, ai|
        ci_id = DB.conn[:attack_events].where(id: aid).get(:creature_instance_id)
        ci    = DB.conn[:creature_instances].where(id: ci_id).first
        target_str = "#{ci[:noun].upcase} (#{ci[:exist_id]})"

        tree = format_attack_tree(aid)

        tree.each_with_index do |row, ri|
          rows << (ri == 0 ? row + [target_str] : row + [''])
        end

        rows << ['', '', '', '', '', ''] if ai < atk_ids.size - 1
      end

      cols = %w[Attack DMG STATUS CRIT_STUFFS FATAL? TARGET]
      print_ascii_table(header, cols, rows)
    end

    # Generates a report for a specific attack type and index.
    #
    # @param attack_name [String, nil] The name of the attack to report on. If nil or invalid, usage information is displayed.
    # @param attack_index [Integer, nil] The index of the attack to report on. If nil, the last attack is reported.
    # @return [void] Outputs the report to the console.
    # @raise [StandardError] If an unknown attack type is provided.
    # @example
    #   attack_report("fire", 2)
    def self.attack_report(attack_name = nil, attack_index = nil)
      # 1) list of valid types
      valid_names = DB.conn[:attack_types].select_map(:name)

      # If no name or invalid name, print choices
      if attack_name.nil? ||
         !valid_names.map(&:upcase).include?(attack_name.to_s.upcase)
        respond <<~USAGE

        Usage:
          attack_report(attack, [index])
        Examples:
          attack_report("fire", 2)
          attack_report("natures_fury", -1)

        USAGE

        list_attacks
        return
      end

      # normalize to DB casing
      chosen = valid_names.find { |n| n.upcase == attack_name.to_s.upcase }

      # build (or fetch) the in-memory sequence of global IDs
      seq = sequence_for(chosen)
      if seq.empty?
        respond "No recorded #{chosen} attacks."
        return
      end

      # pick which global attack_id to show
      if attack_index
        raw = attack_index.to_i
        idx = raw > 0 ? raw - 1 : seq.size + raw
        unless idx.between?(0, seq.size - 1)
          respond "Invalid index #{idx} for #{chosen} (have #{seq.size} events)."
          return
        end
      else
        idx = seq.size - 1
      end

      ord = idx + 1
      selected_id = seq[idx]

      # fetch & render exactly that global ID (still restricted to this type)
      attack = fetch_attack(chosen, selected_id)
      target = DB.conn[:creature_instances]
                 .where(id: attack[:creature_instance_id])
                 .first

      header =  "Report for #{chosen} (#{ord})   " \
                "Target (#{target[:id]}) #{target[:display_name]}"
      rows   = format_attack_tree(selected_id)

      print_ascii_table(header,
                        %w[Attack DMG STATUS CRIT_STUFFS FATAL?],
                        rows)
    end

    # Generates a report for a specific flare type and session.
    #
    # @param flare_type [String, nil] The type of flare to report on. If nil, usage information is displayed.
    # @param session_id [Integer, nil] The ID of the session to filter the report by. If nil, all sessions are included.
    # @return [Hash, void] Returns a report hash or outputs the report to the console.
    # @raise [StandardError] If an unknown flare type is provided or if an error occurs during report generation.
    # @example
    #   flare_report("BRIAR", 2)
    def self.flare_report(flare_type = nil, session_id = nil)
      # 1) no args -> usage + list of flare types
      if flare_type.nil?
        respond <<~USAGE

          Usage:
            flare_report("FLARE", [index])

          Examples:
            flare_report("BRIAR", 2)
            flare_report("BLESSINGs_FLOURISH", -1)

        USAGE
        list_flares
        return
      end
      
      begin
        # Find the flare type ID (case insensitive)
        flare_type_record = DB.conn[:flare_types].where(Sequel.function(:upper, :name) => flare_type.upcase).first
        
        unless flare_type_record
          Log.log(:ERROR, "REPORT", "Flare type not found: #{flare_type}")
          display_flare_types
          return { error: "Flare type not found" }
        end
        
        flare_type_id = flare_type_record[:id]
        flare_type_name = flare_type_record[:name]
        
        # Build the SQL query for flare data
        session_condition = session_id ? "AND fe.session_id = #{session_id.to_i}" : ""
        session_info = session_id ? "for session #{session_id}" : "across all sessions"
        Log.log(:INFO, "REPORT", "Collecting flare data #{session_info}")

          report = {
            flare_type: flare_type_name,
            session_id: session_id,
            session_info: session_info
          }
        
        flare_query = <<-SQL
          SELECT
            fe.id,
            dc.is_fatal,
            dc.damage,
            dc.critical_rank,
            loc.name AS location_name
          FROM flare_events fe
          JOIN flare_types ft ON fe.flare_type_id = ft.id
          LEFT JOIN damage_components dc ON dc.flare_id = fe.id
          LEFT JOIN locations loc ON dc.location_id = loc.id
          WHERE ft.id = ? #{session_condition}
        SQL
        
        # Execute the query
        flares = DB.conn[flare_query, flare_type_id].all
        
        if flares.empty?
          Log.log(:WARN, "REPORT", "No data found for flare type: #{flare_type_name}")
          return { error: "No data found for this flare type" }
        end

        total_flares     = flares.size
        fatal_count      = flares.count { |f| f[:is_fatal] }
        crit_count       = flares.map { |f| f[:critical_rank] }.compact.size

        report[:count] = {
          total:            total_flares,
          fatal:            fatal_count,
          fatal_percentage: (fatal_count.to_f    / total_flares * 100).round(2),
          criticals:        crit_count,
          crit_percentage:  (crit_count.to_f     / total_flares * 100).round(2)
        }

        # Gather basic statistics
        #damage_values = flares.flat_map { |f| f[:damages] || [] }.reject(&:zero?)
        damage_values = flares.map { |f| f[:damage] }.compact.reject { |d| d == 0 }

          damage_values = flares.map { |f| f[:damage] }.compact.reject(&:zero?)
          sorted = damage_values.sort
          report[:damage] = {
            average: (sorted.sum.to_f / sorted.size).round(2),
            median:  (sorted.size.odd? ?
                        sorted[sorted.size/2] :
                        (sorted[(sorted.size/2)-1] + sorted[sorted.size/2]) / 2.0),
            minimum: sorted.first,
            maximum: sorted.last,
            range:   "#{sorted.first}..#{sorted.last}"
          }
        
        # Skip if no damage data
        if damage_values.empty?
          Log.log(:WARN, "REPORT", "No damage data found for flare type: #{flare_type_name}")
          return { error: "No damage data found for this flare type" }
        end
                
        # Gather critical hit distribution
        crit_ranks = flares.map { |f| f[:critical_rank] }.compact
        total_crits = crit_ranks.size
        rank_counts = (1..9).each_with_object({}) { |r,h| h[r]=0 }
        crit_ranks.each { |r| rank_counts[r] += 1 }
        rank_pcts   = rank_counts.transform_values { |c| (c.to_f/total_crits*100).round(2) }
        high_pct    = (5..9).sum { |r| rank_counts[r] }.to_f/total_crits*100
        low_pct     = (1..4).sum { |r| rank_counts[r] }.to_f/total_crits*100

        group_map = {
          'LEFT EYE' => 'EYES',       'RIGHT EYE' => 'EYES',
          'LEFT ARM' => 'ARMS',       'RIGHT ARM' => 'ARMS',
          'LEFT HAND'=> 'HANDS',      'RIGHT HAND'=> 'HANDS',
          'LEFT LEG' => 'LEGS',       'RIGHT LEG' => 'LEGS',
          'LEFT FOOT'=> 'FEET',       'RIGHT FOOT'=> 'FEET'
        }
        locs = flares.map { |f| f[:location_name] }.compact
        loc_counts = locs.each_with_object(Hash.new(0)) do |loc,h|
          h[ group_map.fetch(loc, loc) ] += 1
        end
        loc_pcts = loc_counts.transform_values { |c| (c.to_f/total_crits*100).round(2) }

        report[:critical_distribution] = {
          by_rank:            rank_pcts,
          low_ranks_pct:      low_pct.round(2),
          high_ranks_pct:     high_pct.round(2),
          by_location:        loc_pcts
        }
        
        # Display the report
        msg = display_flare_report(report)
        
        respond Lich::Messaging.mono(msg)
      rescue => e
        Log.log(:ERROR, "REPORT", "Error generating flare report: #{e.message}")
        Log.log(:ERROR, "REPORT", "Error backtrace: #{e.backtrace.join("\n")}")
        return { error: e.message }
      end
    end

    private

    # Retrieves a sequence of attack event IDs for a given attack type name.
    #
    # @param name [String] The name of the attack type.
    # @return [Array<Integer>] An array of attack event IDs associated with the given attack type.
    # @raise [Sequel::DatabaseError] If there is an issue with the database query.
    # @example
    #   sequence = Reporter.sequence_for("Fireball")
    def self.sequence_for(name)
      @type_sequences[name] ||= DB.conn[:attack_events]
                                 .join(:attack_types, id: :attack_type_id)
                                 .where(Sequel[:attack_types][:name] => name)
                                 .order(Sequel[:attack_events][:id])
                                 .select_map(Sequel[:attack_events][:id])
    end

    # Lists items in columns with a specified title.
    #
    # @param title [String] The title for the list.
    # @param items [Array<String>] The items to be listed.
    # @return [void]
    # @note If the items array is empty, a message indicating no items found will be sent.
    # @example
    #   list_in_columns("Available Attack Types", ["Fireball", "Ice Spike"])
    def self.list_in_columns(title, items)
      return respond Lich::Messaging.mono("\nNo #{title.downcase} found.\n") if items.empty?

      max_len   = items.map(&:length).max
      col_width = max_len + 2

      lines = items.each_slice(5).map do |slice|
        slice.map { |n| n.ljust(col_width) }.join.rstrip
      end

      msg = "\n#{title}:\n"
      lines.each { |ln| msg += "    #{ln}\n" }
      respond Lich::Messaging.mono(msg)
    end

    # Lists all available attack types.
    #
    # @return [void]
    # @example
    #   list_attacks
    def self.list_attacks
      attacks = DB.conn[:attack_types]
                  .select_map(:name)
                  .uniq
                  .sort_by(&:downcase)
      list_in_columns("Available Attack Types", attacks)
    end

    # Lists all available flare types.
    #
    # @return [void]
    # @example
    #   list_flares
    def self.list_flares
      fl = DB.conn[:flare_types]
             .select_map(:name)
             .uniq
             .sort_by(&:downcase)
      list_in_columns("Available Flare Types", fl)
    end

    # Lists the ordinals for flare events.
    #
    # @param ft_name [String] The name of the flare type.
    # @param seq [Array<Integer>] The sequence of flare event IDs.
    # @return [void]
    # @example
    #   list_flare_ordinals("Fire Flare", [1, 2, 3])
    def self.list_flare_ordinals(ft_name, seq)
      msg = "\n> #{ft_name} Events (index ? ID):"
      seq.each_with_index { |id,i| msg += "   #{i+1} => #{id}" }
      respond Lich::Messaging.mono(msg)
    end

    # Formats a tree structure for a flare event.
    #
    # @param flare_id [Integer] The ID of the flare event.
    # @param indent [Integer] The indentation level for formatting.
    # @return [Array<Array<String>>] A nested array representing the flare event structure.
    # @raise [Sequel::DatabaseError] If there is an issue with the database query.
    # @example
    #   format_flare_tree(1)
    def self.format_flare_tree(flare_id, indent = 0)
      rows = []
      fl   = DB.conn[:flare_events].where(id: flare_id).first
      name = DB.conn[:flare_types].where(id: fl[:flare_type_id]).get(:name)

      # gather damage components
      comps = DB.conn[:damage_components]
                .where(flare_id: flare_id)
                .join(:locations,
                      Sequel[:locations][:id] => Sequel[:damage_components][:location_id])
                .join(:critical_types,
                      Sequel[:critical_types][:id] => Sequel[:damage_components][:critical_type])
                .select(
                  Sequel[:damage_components][:damage],
                  Sequel[:damage_components][:is_fatal],
                  Sequel[:locations][:name].as(:loc),
                  Sequel[:damage_components][:critical_rank].as(:rank),
                  Sequel[:critical_types][:name].as(:ctype)
                )
                .all

      # first damage on header
      if first = comps.shift
        crit = "[#{first[:loc]} R#{first[:rank]} #{first[:ctype]}]"
        rows << [
          (' ' * indent) + name,
          first[:damage].to_s,
          '',        # flares have no status
          crit,
          first[:is_fatal] ? 'Y' : 'N'
        ]
      else
        rows << [indent, name, '', '', '', '']
      end

      # remaining damage
      comps.each do |dc|
        crit = "[#{dc[:loc]} R#{dc[:rank]} #{dc[:ctype]}]"
        rows << [
          ' ' * indent,
          dc[:damage].to_s,
          '',
          crit,
          dc[:is_fatal] ? 'Y' : 'N'
        ]
      end

      # nested child attack
      if fl[:child_attack_id]
        rows.concat format_attack_tree(fl[:child_attack_id], indent + 2)
      end

      rows
    end

    # Lists all available creature nouns.
    #
    # @return [void]
    # @example
    #   list_nouns
    def self.list_nouns
      nouns = DB.conn[:creature_instances]
                .select_map(:noun)
                .uniq
                .sort_by(&:downcase)
      list_in_columns("Available Creature Nouns", nouns)
    end

    # Lists all available sequence types.
    #
    # @return [void]
    # @example
    #   list_sequence_types
    def self.list_sequence_types
      types = DB.conn[:sequence_types]
                .select_map(:name)
                .uniq
                .sort_by(&:downcase)
      list_in_columns("Available Sequence Types", types)
    end

    # Lists the ordinals for attacks of a given name.
    #
    # @param name [String] The name of the attack type.
    # @param seq [Array<Integer>] The sequence of attack event IDs.
    # @return [void]
    # @example
    #   list_ordinals_for("Fireball", [1, 2, 3])
    def self.list_ordinals_for(name, seq)
      msg = "\n> #{name} Attacks Ordinals (index => global ID):"
      seq.each_with_index do |id, i|
        msg += "   #{i+1} => #{id}"
      end
      respond Lich::Messaging.mono(msg)
    end

    # Fetches an attack event by name or ID.
    #
    # @param name [String, nil] The name of the attack type (optional).
    # @param id [Integer, nil] The ID of the attack event (optional).
    # @return [Hash, nil] A hash representing the attack event, or nil if not found.
    # @raise [Sequel::DatabaseError] If there is an issue with the database query.
    # @example
    #   attack = fetch_attack("Fireball", nil)
    def self.fetch_attack(name, id)
      ds = DB.conn[:attack_events]
            .join(:attack_types, id: :attack_type_id)
            .select_all(:attack_events)
            .select_append(Sequel[:attack_types][:name].as(:atype))
      if id
        ds.where(Sequel[:attack_events][:id] => id).first
      else
        ds.where(Sequel[:attack_types][:name] => name)
          .order(Sequel.desc(Sequel[:attack_events][:id]))
          .first
      end
    end

    # Formats a tree structure for an attack event.
    #
    # @param attack_id [Integer] The ID of the attack event.
    # @param indent [Integer] The indentation level for formatting.
    # @return [Array<Array<String>>] A nested array representing the attack event structure.
    # @raise [Sequel::DatabaseError] If there is an issue with the database query.
    # @example
    #   format_attack_tree(1)
    def self.format_attack_tree(attack_id, indent = 0)
      rows = []

      atk = DB.conn[:attack_events]
             .join(:attack_types, id: :attack_type_id)
             .where(Sequel[:attack_events][:id] => attack_id)
             .select_all(:attack_events)
             .select_append(Sequel[:attack_types][:name].as(:atype))
             .first
      status = DB.conn[:status_events]
                  .join(:status_types, id: :status_type)
                  .where(applied_by_attack: attack_id)
                  .select_map(:name)
                  .join(',')

      comps = DB.conn[:damage_components]
                .where(attack_id: attack_id, flare_id: nil)
                .join(
                 :locations,
                  Sequel[:locations][:id] => Sequel[:damage_components][:location_id]
                )
                .join(
                  :critical_types,
                  Sequel[:critical_types][:id] => Sequel[:damage_components][:critical_type]
                )
                .select(
                  Sequel[:damage_components][:damage],
                  Sequel[:damage_components][:is_fatal],
                  Sequel[:locations][:name].as(:loc),
                  Sequel[:damage_components][:critical_rank].as(:rank),
                  Sequel[:critical_types][:name].as(:ctype)
                )
                .all

      outcome_id = atk[:outcome_id]
      outcome_name = DB.conn[:outcome_types]
                       .where(id: outcome_id)
                       .get(:name)
      
      echo outcome_name
      echo outcome_name

      if outcome_id != 1
        rows << [
          (' ' * indent) + atk[:atype],
          '',            # no damage
          status,        # still show any statuses
          outcome_name,  # show MISS, FUMBLE, etc.
          ''             # no fatal flag
        ]          
      elsif first = comps.shift
        crit = "[#{first[:loc]} R#{first[:rank]} #{first[:ctype]}]"
        rows << [
          (' ' * indent) + atk[:atype],
          first[:damage].to_s,
          status,
          crit,
          first[:is_fatal] ? 'Y' : 'N'
        ]
      else
        rows << [ (' ' * indent) + atk[:atype], '', status, '', '' ]
      end

      comps.each do |dc|
        crit = "[#{dc[:loc]} R#{dc[:rank]} #{dc[:ctype]}]"
        rows << [
          ' ' * indent,
          dc[:damage].to_s,
          '',
          crit,
          dc[:is_fatal] ? 'Y' : 'N'
        ]
      end

      DB.conn[:flare_events]
        .where(attack_id: attack_id)
        .order(:flare_sequence)
        .all
        .each do |flare|
          name = DB.conn[:flare_types]
                   .where(id: flare[:flare_type_id])
                   .get(:name)

          flare_comps = DB.conn[:damage_components]
                          .where(flare_id: flare[:id])
                          .join(
                          :locations,
                          Sequel[:locations][:id] => Sequel[:damage_components][:location_id]
                        )
                        .join(
                          :critical_types,
                          Sequel[:critical_types][:id] => Sequel[:damage_components][:critical_type]
                        )
                        .select(
                          Sequel[:damage_components][:damage],
                          Sequel[:damage_components][:is_fatal],
                          Sequel[:locations][:name].as(:loc),
                          Sequel[:damage_components][:critical_rank].as(:rank),
                          Sequel[:critical_types][:name].as(:ctype)
                        )
                        .all

          if first = flare_comps.shift
            crit = "[#{first[:loc]} R#{first[:rank]} #{first[:ctype]}]"
            rows << [
              (' ' * (indent + 2)) + name,
              first[:damage].to_s,
              '',          # no status on flares
              crit,
              first[:is_fatal] ? 'Y' : 'N'
            ]
          else
            rows << [ (' ' * (indent + 2)) + name, '', '', '', '' ]
          end

          if flare[:child_attack_id]
            rows.concat format_attack_tree(flare[:child_attack_id], indent + 4)
          else
            flare_comps.each do |dc|
              crit = "[#{dc[:loc]} R#{dc[:rank]} #{dc[:ctype]}]"
              rows << [
                ' ' * (indent + 2),
                dc[:damage].to_s,
                '',
                crit,
                dc[:is_fatal] ? 'Y' : 'N'
              ]
            end
          end
        end
      rows
    end


      # Formats a single attack's details for reporting.
    #
    # @param attack_id [Integer] the ID of the attack to format
    # @param indent [Integer] the number of spaces to indent the output
    # @return [Array<String>] formatted attack details including type, damage, status, critical information, and fatality
    # @raise [Sequel::DatabaseError] if there is an issue with the database query
    # @example
    #   format_single_attack(1, 2)
    def self.format_single_attack(attack_id, indent)
      attack = DB.conn[:attack_events]
        .join(:attack_types, id: :attack_type_id)
        .where(Sequel[:attack_events][:id] => attack_id)
        .select_append(Sequel[:attack_types][:name].as(:atype))
        .first

      # DMG: prefer resolution.result_total, fallback to sum(damage_components)
      res = DB.conn[:attack_resolutions].where(attack_id: attack_id).first
      dmg = res && res[:result_total] || 
            DB.conn[:damage_components].where(attack_id: attack_id, flare_id: nil)
                                 .sum(:damage)
                                 .to_i

      # STATUS: list any status_events applied_by_attack
      status = DB.conn[:status_events]
                 .join(:status_types, id: :status_type)
                 .where(applied_by_attack: attack_id)
                 .select_map(:name)
                 .join(',')

      # CRIT STUFFS & FATAL?
      crit_rows = DB.conn[:damage_components]
                    .join(:locations, Sequel[:locations][:id] => Sequel[:damage_components][:location_id])
                    .join(:critical_types, Sequel[:critical_types][:id] => Sequel[:damage_components][:critical_type])
                    .where(Sequel[:damage_components][:attack_id] => attack_id, Sequel[:damage_components][:flare_id]  => nil)
                    .select_map([ Sequel[:locations][:name], Sequel[:damage_components][:critical_rank], Sequel[:critical_types][:name], Sequel[:damage_components][:is_fatal] ])

      crit_str  = crit_rows
                    .map { |loc, rk, typ, _fatal| "#{loc} R#{rk} #{typ}" }
                    .join('; ')
      fatal     = crit_rows.any? { |_, _, _, is_f| is_f } ? 'Y' : 'N'

      [ indent,
        attack[:atype],
        dmg.to_s,
        status,
        crit_str.empty? ? '' : "[#{crit_str}]",
        fatal
      ]
    end

    # Formats a single flare's details for reporting.
    #
    # @param flare [Hash] the flare data containing its ID and type ID
    # @param indent [Integer] the number of spaces to indent the output
    # @return [Array<String>] formatted flare details including type, damage, status, critical information, and fatality
    # @raise [Sequel::DatabaseError] if there is an issue with the database query
    # @example
    #   format_single_flare({id: 1, flare_type_id: 2}, 2)
    def self.format_single_flare(flare, indent)
      # total damage on that flare
      dmg, fatal = DB.conn[:damage_components]
                     .where(flare_id: flare[:id])
                     .select_map([:damage, :is_fatal])
                     .transpose
                     .then { |dmg_arr, fat_arr| [dmg_arr.sum, fat_arr.any? ? 'Y' : 'N'] rescue [0,'N'] }

      # no status for simple flares in this schema
      crit_records = DB.conn[:damage_components]
                       .join(:locations, Sequel[:locations][:id] => Sequel[:damage_components][:location_id])
                       .join(:critical_types, Sequel[:critical_types][:id] => Sequel[:damage_components][:critical_type])
                       .where(Sequel[:damage_components][:flare_id] => flare[:id])
                       .select_map([ Sequel[:locations][:name], Sequel[:damage_components][:critical_rank], Sequel[:critical_types][:name]])
      crit_str = crit_records
                   .map { |loc, rk, typ| "#{loc} R#{rk} #{typ}" }
                   .join('; ')

      [
        (' ' * indent) +
          DB.conn[:flare_types]
            .where(id: flare[:flare_type_id])
            .get(:name),
        dmg.to_s,
        '',                               # STATUS blank
        crit_str.empty? ? '' : "[#{crit_str}]",
        fatal
      ]
    end

    # Fetches the name of the attack type for a given attack ID.
    #
    # @param child_attack_id [Integer] the ID of the child attack
    # @return [String] the name of the attack type
    # @raise [Sequel::DatabaseError] if there is an issue with the database query
    # @example
    #   fetch_attack_type_name(1)
    def self.fetch_attack_type_name(child_attack_id)
      DB.conn[:attack_events]
        .join(:attack_types, id: :attack_type_id)
        .where(Sequel[:attack_events][:id] => child_attack_id)
        .get(Sequel[:attack_types][:name])
    end

    # Displays the available flare types in a formatted manner.
    #
    # @return [void]
    # @example
    #   display_flare_types
    def self.display_flare_types
      flare_types = DB.conn[:flare_types].order(:name).map { |ft| ft[:name] }
      
      respond "\n"
      respond "=== Available Flare Types ==="
      flare_types.each_slice(4) do |slice|
        respond slice.map { |name| name.ljust(20) }.join
      end
      respond "\n"
    end

    # Displays a report for a specific flare.
    #
    # @param r [Hash] the report data containing flare type and session info
    # @return [String] formatted flare report
    # @raise [KeyError] if expected keys are missing in the report data
    # @example
    #   display_flare_report({flare_type: 'fire', session_info: 'Session 1', count: {total: 10, fatal: 2, fatal_percentage: 20}, damage: {average: 50, median: 45, range: 10}, critical_distribution: {by_rank: [[1, 50], [2, 30]], by_location: [['head', 40]], low_ranks_pct: 10, high_ranks_pct: 20}})
    def self.display_flare_report(r)
      raw_name = r[:flare_type]
      clean_name = raw_name.gsub("_"," ").split.map(&:capitalize).join(" ")
      hdr = "\n=== #{clean_name} Flare Report #{r[:session_info]} ===\n"
      underline = "=" * hdr.length

      # summary two-column
      msg += hdr
      msg += underline
      msg += format("\n    %-25s %15s", "Count: #{r[:count][:total]}",   "Average: #{r[:damage][:average]}")
      msg += format("\n    %-25s %12s", "Fatal: #{r[:count][:fatal]} (#{r[:count][:fatal_percentage]}%)",
                                                "Median: #{r[:damage][:median]}")
      msg += format("\n    %-25s %15s", "Crits: #{r[:count][:criticals]} (#{r[:count][:crit_percentage]}%)",
                                                "Range: #{r[:damage][:range]}")
      msg += "\n"

      # build sorted arrays of [key, pct]
      ranks = r[:critical_distribution][:by_rank].sort_by(&:first)
      locs  = r[:critical_distribution][:by_location].sort_by(&:first)

      # figure out how many rows we need
      rows = [ranks.size, locs.size].max

      # header for side-by-side tables
      msg += "\n     Crit Rank                   Crit Location"
      msg += "\n  Rank   | Percent           Location | Percent"
      msg += "\n  ------ | --------          -------- | --------"

      # walk both arrays by index
      rows.times do |i|
        rank, pct     = ranks[i] || [nil, 0]
        loc, loc_pct  = locs[i]  || ["", 0]

        # format each side with placeholders when missing
        left  = rank ? format("Rank %-1d | %6.2f%%", rank, pct) : "                "
        right = format("     %-7s | %6.2f%%", loc, loc_pct)

        msg += "\n  #{left}       #{right}"
      end

      # summary rows for low/high ranks
      msg += format("\n  %-6s | %6.2f%%", "R1 R4", r[:critical_distribution][:low_ranks_pct])
      msg += format("\n  %-6s | %6.2f%%", "R5 R9", r[:critical_distribution][:high_ranks_pct])
      return msg.to_s
    end

    # Prints an ASCII table with the given title, columns, and rows.
    #
    # @param title [String] the title of the table
    # @param cols [Array<String>] the column headers
    # @param rows [Array<Array>] the data rows to display
    # @return [void]
    # @example
    #   print_ascii_table("My Table", ["Column 1", "Column 2"], [["Row 1 Col 1", "Row 1 Col 2"], ["Row 2 Col 1", "Row 2 Col 2"]])
    def self.print_ascii_table(title, cols, rows)
      # Helper to strip out <...> tags for width-calculations
       strip_tags = ->(s){ s.to_s.gsub(/<[^>]+>/, '') }

      # compute column widths
      widths = cols.each_with_index.map do |col, i|
        max_cell = rows.map { |r| strip_tags.call(r[i]).length }.max || 0
        [ strip_tags.call(col).length, max_cell ].max
      end

      # build separators
      sep = "\n+" + widths.map { |w| '-' * (w + 2) }.join('+') + '+'
      
      msg = title
      msg += sep

      header = cols.each_with_index.map do |col, i|
        text = col.to_s
        pad = widths[i] - strip_tags.call(text).length
        " #{text}#{' '*pad} "
      end.join('|')
      msg += "\n|#{header}|"
      msg += sep

      rows.each do |row|
        line = cols.each_with_index.map do |_col, i|
          cell = row[i] || ''
          text = cell.to_s
          pad = widths[i] - strip_tags.call(text).length
          " #{text}#{' '*pad} "
        end.join('|')
        msg += "\n|#{line}|"
      end
      msg += sep
      respond Lich::Messaging.mono(msg)
    end
  end
end